<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Basic Structure of an Electrical Power System</title><meta name="author" content="Noha Magdy"/><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 h2 { color: #F00; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 22pt; }
 h1 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 24pt; }
 .s1 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 16pt; }
 .s2 { color: #001F5F; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 .s3 { color: #2D74B5; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 16pt; }
 .s4 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 h3 { color: #2D74B5; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 14pt; }
 .p, p { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; margin:0pt; }
 .s5 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 12pt; }
 .s6 { color: black; font-family:"Cambria Math", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s7 { color: #44536A; font-family:"Times New Roman", serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 9pt; }
 h4 { color: #2D74B5; font-family:"Times New Roman", serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 13pt; }
 .s8 { color: #1F4D78; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s9 { color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s10 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .a { color: #0462C1; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 10pt; }
 .s12 { color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s13 { color: #0462C1; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 10pt; }
 li {display: block; }
 #l1 {padding-left: 0pt; }
 #l1> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 li {display: block; }
 #l2 {padding-left: 0pt;counter-reset: d1 1; }
 #l2> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)"- "; color: black; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; }
 #l2> li:first-child>*:first-child:before {counter-increment: d1 0;  }
</style></head><body><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;"><span><img width="139" height="112" alt="image" src="knn_report/Image_001.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-top: 4pt;padding-left: 75pt;text-indent: 0pt;text-align: center;">Report</h2><p style="text-indent: 0pt;text-align: left;"><br/></p><h1 style="padding-left: 112pt;text-indent: 0pt;text-align: left;">Noisy MNIST classification using KNN</h1><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">by: Gad Mohamed</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">20/9/2020</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s3" style="padding-top: 12pt;padding-left: 76pt;text-indent: 0pt;text-align: left;"><a name="bookmark0">Table of Contents</a></p><p style="padding-top: 1pt;padding-left: 77pt;text-indent: 0pt;text-align: left;"><a href="#bookmark0" class="s4">Table of Contents 2</a></p><p style="padding-top: 6pt;padding-left: 77pt;text-indent: 0pt;text-align: left;"><a href="#bookmark1" class="s4">Introduction 3</a></p><p style="padding-top: 6pt;padding-left: 77pt;text-indent: 0pt;text-align: left;"><a href="#bookmark2" class="s4">Methodology 5</a></p><p style="padding-top: 6pt;padding-left: 89pt;text-indent: 0pt;text-align: left;"><a href="#bookmark3" class="s4">Preprocessing 5</a></p><p style="padding-top: 6pt;padding-left: 101pt;text-indent: 0pt;text-align: left;"><a href="#bookmark4" class="s4">Median filter 5</a></p><p style="padding-top: 6pt;padding-left: 101pt;text-indent: 0pt;text-align: left;"><a href="#bookmark5" class="s4">cropping 6</a></p><p style="padding-top: 6pt;padding-left: 101pt;text-indent: 0pt;text-align: left;"><a href="#bookmark6" class="s4">PCA 6</a></p><p style="padding-top: 6pt;padding-left: 89pt;text-indent: 0pt;text-align: left;"><a href="#bookmark7" class="s4">Building KNN classifier 7</a></p><p style="padding-top: 6pt;padding-left: 77pt;text-indent: 0pt;text-align: left;"><a href="#bookmark8" class="s4">Results 8</a></p><p style="padding-top: 6pt;padding-left: 89pt;text-indent: 0pt;text-align: left;"><a href="#bookmark9" class="s4">Leave one out cross validation 8</a></p><p style="padding-top: 6pt;padding-left: 89pt;text-indent: 0pt;text-align: left;"><a href="#bookmark10" class="s4">Model evaluation on test set 9</a></p><p style="padding-top: 6pt;padding-left: 89pt;text-indent: 0pt;text-align: left;"><a href="#bookmark11" class="s4">Confusion matrix 10</a></p><p style="padding-top: 6pt;padding-left: 77pt;text-indent: 0pt;text-align: left;"><a href="#bookmark12" class="s4">Conclusion 11</a></p><p style="padding-top: 6pt;padding-left: 77pt;text-indent: 0pt;text-align: left;"><a href="#bookmark13" class="s4">References 12</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h3 style="padding-left: 76pt;text-indent: 0pt;text-align: left;"><a name="bookmark1">Introduction</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 8pt;padding-left: 77pt;text-indent: 18pt;line-height: 111%;text-align: left;">K-nearest-neighbor (KNN) is a supervised machine learning algorithm that solves classification and regression problems. Despite being a supervised algorithm, KNN does not need training or learning a mapping function, instead, it relies on case-dependent predefined parameters to match the query data point to the “closest” training data point [1]. KNN parameters are:</p><ul id="l1"><li><p class="s5" style="padding-top: 8pt;padding-left: 95pt;text-indent: -18pt;line-height: 110%;text-align: left;">Distance function. <span class="p">The distance metric used to compare the features of two data points. For each query point, KNN applies this function n times between the query point and each other data point in the training set. With n equals the number of data points in the training set.</span></p></li><li><p class="s5" style="padding-left: 95pt;text-indent: -18pt;line-height: 110%;text-align: left;">K value. <span class="p">After comparing the query point to all points in the training set, and sort training set points ascendingly from the closest to the farthest, K is the number of closest neighbors to consider their votes in query evaluation, K is usually chosen as an odd number to have a tiebreaker.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 8pt;padding-left: 77pt;text-indent: 17pt;line-height: 111%;text-align: left;">Both KNN parameters are chosen, empirically, based on how the data features in concern respond to parameters variations. However, there are minimal assumption that must be met to ensure KNN is the right algorithm to use on data:</p></li><li><p class="s5" style="padding-top: 8pt;padding-left: 94pt;text-indent: -18pt;line-height: 110%;text-align: left;">Feature importance are contained within its value. <span class="p">KNN, blindly, applies the distance function on features i.e. it does not weight features. Consequently, to give KNN a sense of the relative importance of each feature, features values should also represent the importance of the feature. More on that in data preprocessing section.</span></p></li><li><p style="padding-left: 94pt;text-indent: -18pt;line-height: 111%;text-align: left;"><b>Relatively small Dataset. </b>It is well known in machine learning algorithms that the smaller the dataset, the lower the performance. However, since KNN doesn’t learn a function from the data and needs to, iteratively, check each sample for each new query, a major setback in KNN is the high computational time or more precisely, the dependence of computational time on dataset size. i.e. the running complexity of KNN is O(kn + dn) for n is the dataset size, d is the vector dimension, and k is the K value. However, complexity changes depending on the implementation. For example, if instead of iterating k times to choose the lowest k distances we sort the distances, the complexity becomes O(nlong(n) + dn) <span class="s6">≈ </span>O(n*log(n)).</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li><p class="s5" style="padding-top: 11pt;padding-left: 94pt;text-indent: -18pt;line-height: 111%;text-align: left;">Descriptive separable features. <span class="p">Raw features my represent a data point, but they do not always characterize it. Figure 1 shows samples from a face recognition task. Using KNN in that problem will be as accurate as random guessing since raw pixel values are low-level representation while we want features that encode the high-level information like hair style, skin tone, etc.… Needless to say, face recognition is an extreme example because face features are much more complicated than the MNIST features in hand, but the general idea here is, KNN assumes that the features on which the distance function is applied must </span>directly <span class="p">describe not only the data, but the differences we are targeting within the data.</span></p></li></ul><p style="padding-left: 99pt;text-indent: 0pt;text-align: left;"><span><img width="533" height="319" alt="image" src="knn_report/Image_002.jpg"/></span></p><p class="s7" style="padding-top: 9pt;padding-left: 142pt;text-indent: 0pt;text-align: left;">Figure 1 Raw features (pixel values) does not describe high-level aspects of a face. Source [2]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h3 style="padding-top: 4pt;padding-left: 76pt;text-indent: 0pt;text-align: left;"><a name="bookmark2">Methodology</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 77pt;text-indent: 36pt;line-height: 108%;text-align: left;">I started working by creating a quick baseline to assess each step I manipulate the data by comparing the result with the baseline performance. Fig 2. (a) shows the baseline performance on the normal MNIST and (b) shows the performance on the given noisy MNIST. Clearly, data preprocessing the data is crucial in this task. How to systematically approach the data? Each point considered in the aforementioned KNN assumptions will steadily boost performance or speed up the algorithm a bit.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-top: 7pt;padding-left: 76pt;text-indent: 0pt;text-align: left;"><a name="bookmark3">Preprocessing</a></h4><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-left: 76pt;text-indent: 0pt;text-align: left;"><a name="bookmark4">Median filter</a></p><p style="padding-top: 1pt;padding-left: 77pt;text-indent: 35pt;line-height: 111%;text-align: left;">In accordance with the first assumption, median filter is used to remove noise. Also, although binarizing the image make it seem clearer, we must not binarize the image because it’s important to give preserve the different values of pixels since they indicate the importance of the pixel to the classification of the image. For example, the low pixel values in the edge of a digit will have a lower weight – thus less important - in the distance than the pixel in the center of the digit. Fig. 2 shows the data before and after denoising as well as binarization effect on images.</p><p style="padding-left: 77pt;text-indent: 0pt;line-height: 111%;text-align: left;">Note: some parts of the digits have been erased due to binarization. However, this is not our focus here as this can easily be fixed using lower binarization threshold, our concern here is that all pixels in the binary image will either be on or off which means we loss the information of the relative importance of each pixel, which is given through different “on” values between edge and center of the digit.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 78pt;text-indent: 0pt;text-align: left;"><span><img width="611" height="243" alt="image" src="knn_report/Image_003.jpg"/></span></p><p class="s7" style="padding-top: 10pt;padding-left: 77pt;text-indent: 0pt;text-align: left;">Figure 2 Top row: raw noisy images. Middle row: denoised using median filter (kernel size = 3). Bottom row: denoised and binarized images (degrades performance because it losses information _ pixels importance)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 2pt;padding-left: 76pt;text-indent: 0pt;text-align: left;"><a name="bookmark5">cropping</a></p><p style="padding-top: 1pt;padding-left: 77pt;text-indent: 35pt;line-height: 111%;text-align: left;">A smart move to reduce size as well as to better align data vectors for pixel-wise comparison, thereafter, is to crop images by removing all zero pixels in the four edges. Fig. 3 shows samples before and after cropping.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 81pt;text-indent: 0pt;text-align: left;"><span><img width="622" height="135" alt="image" src="knn_report/Image_004.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 76pt;text-indent: 0pt;text-align: left;">Figure 3Top row: samples before applying cropping. Bottom row: samples after applying cropping</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s8" style="padding-top: 2pt;text-indent: 0pt;text-align: right;"><a name="bookmark6">PCA</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 14pt;text-indent: 0pt;text-align: left;">Back in the “descriptive separable features” assumption we presented the problem of face</p><p style="padding-top: 1pt;padding-left: 77pt;text-indent: 0pt;line-height: 111%;text-align: left;">recognition, now we discuss the solution. Although face recognition state-of-art methods today are deep learning based relying on architectures like the Siamese network, a decent and cheap approach [3] is to convert the raw low-level features (pixels) of the image to high-level features (principle components) using dimensionality reduction tools like principle components analysis (PCA) or singular value decomposition (SVD). The key word here is variance. Dimensionality reduction tools will compute the covariance matrix of the data and choose the most P variant dimensions. Now instead of useless pixels, each new dimension is a weighted combination of pixels presenting a high-level feature [4]. P, the number of principle components, is another parameter added to our list.</p><p style="padding-top: 4pt;padding-left: 77pt;text-indent: 36pt;line-height: 111%;text-align: left;">The value of P which yields the highest model accuracy is 50 (compared to 28*28=784) which also resulted in speeding up the algorithm. However, Fig. 4 shows the plot of sample of data of different labels (denoted with different point color) in a 3D space after using P value of 3. This also gives us an idea on how much “separable” our data is.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 153pt;text-indent: 0pt;text-align: left;"><span><img width="505" height="437" alt="A close up of a map  Description automatically generated" title="A close up of a map  Description automatically generated" src="knn_report/Image_005.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-top: 4pt;padding-left: 259pt;text-indent: -172pt;text-align: left;">Figure 4 a 3D plot of images with different labels using P value = 3. we can identify clusters of points having the same color (representing the same class)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-top: 7pt;padding-left: 76pt;text-indent: 0pt;text-align: left;"><a name="bookmark7">Building KNN classifier</a></h4><p style="padding-top: 2pt;padding-left: 77pt;text-indent: 36pt;line-height: 108%;text-align: left;">KNN is relatively easy to implement. I designed the code with modularity in mind so that I can define different distance and preprocessing functions and, easily, try different combination of them and compare performance.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 77pt;text-indent: 36pt;line-height: 108%;text-align: left;">After choosing the adequate parameters (k value, p value, distance function, …) and the best combination of preprocessing functions, I re-ran the baseline model and compared my implementation to the baseline in terms of accuracy and speed. I found my model to be slightly worse in terms of both accuracy and speed.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 77pt;text-indent: 36pt;line-height: 108%;text-align: justify;">Regarding the accuracy, I think the problem might be in the distance function since I use the standard Euclidean metric while sklearn’s KNN [1] default distance function is ‘minkowski’. Regarding speed, I mentioned earlier the complexity of KNN and how it is affected by using</p><p style="padding-top: 3pt;padding-left: 77pt;text-indent: 0pt;line-height: 108%;text-align: left;">sorting or just iterating K times. Since I use soring (as suggested in the task description), it is justified that my implementation will be slightly slower.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h3 style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark8">Results</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 27pt;text-indent: 0pt;text-align: left;">KNN parameters as well as number of principle components are chosen empirically. I</p><p style="padding-top: 1pt;padding-bottom: 4pt;padding-left: 77pt;text-indent: 0pt;line-height: 111%;text-align: left;">have, iteratively, tried the principle components values range from 3 to 600 (default is 28*28=784) and K values range from 1 to 15. I have also tried custom and off-shelf distance functions like Euclidean and mean absolute error (MAE).</p><p style="padding-left: 92pt;text-indent: 0pt;text-align: left;"><span><img width="590" height="359" alt="A picture containing snow, skiing, riding, person  Description automatically generated" title="A picture containing snow, skiing, riding, person  Description automatically generated" src="knn_report/Image_006.jpg"/></span></p><p class="s7" style="padding-top: 7pt;padding-left: 115pt;text-indent: 0pt;text-align: left;">Figure 5 model accuracy response to different K &amp; P values. The best K value, regardless of the P value, is 1</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark9">Leave one out cross validation</a></h4><p style="padding-top: 2pt;padding-left: 41pt;text-indent: 35pt;line-height: 111%;text-align: left;">In the file named my_KNN_LOOCV.py I apply the leave one out validation algorithm on my implementation of KNN. Using P value of 42 and K value range from 1 to 101 (with step size: 2 to have a tiebreaker). Worth noting here that the P value of 42 compared to the raw features size of 28*28=784 significantly reduced size and increased speed.</p><p style="padding-left: 41pt;text-indent: 0pt;text-align: left;"><span><img width="593" height="659" alt="image" src="knn_report/Image_007.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-top: 4pt;padding-left: 75pt;text-indent: 0pt;text-align: center;">Figure 6 leave-one-out cross validation using P value of 42 and K values range from 1 to 101 with step size 2</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;text-align: left;">Thus, we learn that the optimal values for P and K are 42 and 1, respectively.</p><h4 style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark10">Model evaluation on test set</a></h4><p style="padding-top: 2pt;padding-left: 41pt;text-indent: 0pt;line-height: 111%;text-align: left;">In my_KNN_test.py I tested my KNN implementation on test set and got 93.5% as shown in the following image, using the optimal values for P and K which are 42 and 1, respectively.</p><p style="padding-left: 41pt;text-indent: 0pt;text-align: left;"><span><img width="671" height="66" alt="image" src="knn_report/Image_008.jpg"/></span></p><p class="s7" style="padding-top: 6pt;padding-left: 76pt;text-indent: 0pt;text-align: left;">Figure 7 Model accuracy (correct/total) on the test set</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark11">Confusion matrix</a></h4><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 35pt;line-height: 108%;text-align: left;">Confusion matrix is a statistical analysis tool to assess the performance of the model. Since terms like true positives (TP), true negatives (TN), false positives (FP), and false negatives (FN) usually refer to binary classification, in multi class classification, the confusion matrix is used instead. The diagonal of the matrix shows the correctly predicted classes while all other cells presents deviations or FNs.</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 35pt;line-height: 108%;text-align: left;">The figure below shows confusion matrices of my implementation of KNN on test set. The confusion matrix on the left is built by me while the confusion matrix on the right is built using seaborn visualization library.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;text-align: left;"><span><img width="688" height="348" alt="image" src="knn_report/Image_009.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s7" style="padding-left: 76pt;text-indent: 0pt;text-align: left;">Figure 8 LEFT: confusion matrix of testset built by me. RIGHT: confusion matrix of testset constructed by seaborn</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h3 style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark12">Conclusion</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 77pt;text-indent: 36pt;line-height: 111%;text-align: left;">In the report I presented my work of classification a noisy MNIST handwritten digits data set using KNN. I have explored different preprocessing, and distance functions as well as dimensionality reduction tools all to meet the assumption on which KNN operates.</p><p style="padding-top: 7pt;padding-left: 77pt;text-indent: 36pt;line-height: 111%;text-align: left;">The question of whether this problem is suitable for KNN is also a question of whether it is possible to fulfil KNN’s assumptions to a reasonable extent. Judging on the results we got (93.5% on test set), I think KNN is suitable for such a medium-sized easy- to-interpret data.</p><p style="padding-top: 7pt;padding-left: 77pt;text-indent: 36pt;line-height: 111%;text-align: left;">However, since MNIST dataset is available with much more data, a deep learning based method will yield a better result. In fact, Yann Lecun, maintains a 70000 sized MNIST dataset with a collection of classification methods from 1998 to 2012 and test error rate ranging from 12% to 0.23 (88% to 99.77% accuracy). The list clearly shows deep learning based methods dominating the highest performance methods [5].</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h3 style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark13">References</a></h3><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l2"><li><p class="s9" style="padding-left: 77pt;text-indent: -18pt;text-align: left;">sklearn.neighbors.KNeighborsClassifier — scikit-learn 0.23.2 documentation<span class="s10">. Scikit-learn.org. (2020).</span></p><p class="s13" style="padding-left: 77pt;text-indent: 0pt;line-height: 107%;text-align: left;"><a href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html" class="s12" target="_blank">Retrieved 21 September 2020, from </a>https://scikit-<a href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html" style=" color: #0462C1; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt;" target="_blank"> </a><a href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html" class="a" target="_blank">learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html</a><a href="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html" class="s12" target="_blank">.</a></p></li><li><p class="s10" style="padding-left: 77pt;text-indent: -18pt;line-height: 107%;text-align: left;">kutz, n. (2020). <i>Data-Driven Modeling &amp; Scientific Computation: Methods for Complex Systems &amp; Big Data </i>(2nd ed.). Oxford University Press.</p></li><li><p class="s10" style="padding-left: 77pt;text-indent: -18pt;line-height: 107%;text-align: left;">gad, g. (2020). <i>gadm21/Face-recognition-using-PCA-and-SVD</i>. GitHub. Retrieved 21 September 2020, from<a href="https://github.com/gadm21/Face-recognition-using-PCA-and-SVD" style=" color: #0462C1; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt;" target="_blank"> </a><a href="https://github.com/gadm21/Face-recognition-using-PCA-and-SVD" class="a" target="_blank">https://github.com/gadm21/Face-recognition-using-PCA-and-SVD</a><a href="https://github.com/gadm21/Face-recognition-using-PCA-and-SVD" class="s12" target="_blank">.</a></p></li><li><p class="s9" style="padding-left: 77pt;text-indent: -18pt;line-height: 107%;text-align: left;">A One-Stop Shop for Principal Component Analysis<span class="s10">. Medium. (2020). Retrieved 21 September 2020, from</span><a href="https://towardsdatascience.com/a-one-stop-shop-for-principal-component-analysis-5582fb7e0a9c" class="a" target="_blank"> https://towardsdatascience.com/a-one-stop-shop-for-principal-component-analysis-5582fb7e0a9c</a><a href="https://towardsdatascience.com/a-one-stop-shop-for-principal-component-analysis-5582fb7e0a9c" class="s12" target="_blank">.</a></p></li><li><p class="s9" style="padding-left: 77pt;text-indent: -18pt;line-height: 109%;text-align: left;">MNIST handwritten digit database, Yann LeCun, Corinna Cortes and Chris Burges<span class="s10">. Yann.lecun.com. (2020). Retrieved 21 September 2020, from</span><a href="http://yann.lecun.com/exdb/mnist/" style=" color: #0462C1; font-family:Arial, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt;" target="_blank"> </a><a href="http://yann.lecun.com/exdb/mnist/" class="a" target="_blank">http://yann.lecun.com/exdb/mnist/</a><a href="http://yann.lecun.com/exdb/mnist/" class="s12" target="_blank">.</a></p></li></ol></body></html>
